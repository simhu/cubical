module Transport where

mutual
  V : forall i. U
  data V <i> = `U
             | `Pi (A : V@i) (B : El@i A -> V@i)
             | `K (A : U) (f : let A' : forall j. U
                                   A' = A/i
                               in (x:A'@0) -> (A' ? x) )


  El :  forall i. V@i -> U
  El = <i> split
                      `U -> U
                      `Pi A B -> (x : El@i A) -> El@i (B x)
                      `K A _ -> A

lifting : forall i. (T : V@i) -> (let T' : forall i. V@i
                                      T' = T/i
                                  in (z : El@0 T'@0) -> El@i T)
lifting = <i> split
   `U -> \A -> A
   `Pi A B -> \f a -> let A' : forall j. V@j
                          A' = A/i
                          a' : forall j. El@j A'@j
                          a' = a/i
                      in lifting@i (B a) (f a'@0)
   `K A f -> \x -> [x, f x]@i

lift : (T : forall i. V@i) (z : El@0 T@0) -> forall i. El@i T@i
lift T z = <i> lifting@i T@i z



List : U -> U
data List A = Nil | Cons (x : A) (xs : List A)

append : (A : U) -> List A -> List A -> List A
append A xs = split
  Nil -> xs
  Cons y ys -> Cons y (append A xs ys)

Tree : U -> U
data Tree A = Leaf | Bin (l:Tree A) (x:A) (r : Tree A)

flatten : (A : U) -> Tree A -> List A
flatten A = split
  Leaf -> Nil
  Bin l x r -> append A (Cons x (flatten A r)) (flatten A l)

embed : (A : U) -> List A -> Tree A
embed A = split
  Nil -> Leaf
  Cons x xs -> Bin Leaf x (embed A xs)

True : U
data True = tt

False : U
data False =

EqList : (A : U) -> List A -> List A -> U
EqList A = split
  Nil -> split
    Nil -> True
    Cons _ _ -> False
  Cons x xs -> split
    Nil -> False
    Cons y ys -> -- TODO x == y
                 EqList A xs ys


Related :  (A : U) -> List A -> Tree A -> U
Related A xs t = EqList A xs (flatten A t)


LIST : forall i. (A : U) -> U
LIST A = [List A, Psi (List A) P]
   where P : List A -> U
         P x = (t : Tree A) * Related A x t

rev' : LIST A