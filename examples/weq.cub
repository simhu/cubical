module weq where

primitive
  Id   : (A : U) (a b : A) -> U
  refl : (A : U) (a : A) -> Id A a a
  ext  : (A : U) (B : (a : A) -> U) (f g : (a : A) -> B a)
         (p : ((x : A) -> (Id (B x) (f x) (g x)))) -> Id ((y : A) -> B y) f g
  J : (A : U) (a : A) -> (C : (x : A) -> Id A a x -> U) -> C a (refl A a) ->
      (x : A) -> (p : Id A a x) -> C x p
  Jeq : (A : U) (a : A) -> (C : (x : A) -> Id A a x -> U) -> (d : C a (refl A a)) ->
        Id (C a (refl A a)) d (J A a C d a (refl A a))
  inh : U -> U
  inc : (A : U) -> A -> inh A
--  squash : (A : U) -> prop (inh A)
  squash : (A : U) (a b : inh A) -> Id (inh A) a b
  inhrec : (A : U) (B : U) (p : prop B) (f : A -> B) (a : inh A) -> B
  equivEq : (A B : U) (f : A -> B) (s : (y : B) -> fiber A B f y)
            (t : (y : B) -> (v : fiber A B f y) -> Id (fiber A B f y) (s y) v) ->
            Id U A B
  subst : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
  substInv : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P x -> P a

subst' : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
subst' A P a x p d = J A a (\ x q -> P x) d x p

subst'eq : (A : U) (P : A -> U) (a : A) (d : P a) ->
          Id (P a) d (subst' A P a a (refl A a) d)
subst'eq A P a d = Jeq A a (\ x q -> P x) d

cong : (A B : U) (f : A -> B) (a b : A) (p : Id A a b) -> Id B (f a) (f b)
cong A B f a b p = subst' A (\x -> Id B (f a) (f x)) a b p (refl B (f a))

prop : U -> U
prop A = (a b : A) -> Id A a b

UIP : U -> U
UIP A = (a b : A) -> (p q : Id A a b) -> Id (Id A a b) p q

comp : (A : U) -> (a b c : A) -> Id A a b -> Id A b c -> Id A a c
comp A a b c p q = subst' A (Id A a) b c q p


compInvIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) p (comp A a b b p (refl A b))
compInvIdr A a b p = subst'eq A (\x -> Id A a x) b p

inv : (A : U) -> (a b :A) -> Id A a b -> Id A b a
inv A a b p = subst' A (\ x -> Id A x a) a b p (refl A a)


compIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) (comp A a b b p (refl A b)) p
compIdr A a b p = inv (Id A a b) p (comp A a b b p (refl A b)) (compInvIdr A a b p)


compInvIdl : (A : U) -> (b c : A) -> (q : Id A b c) ->
          Id (Id A b c) q (comp A b b c (refl A b) q)
compInvIdl A b c q = J A b (\c q -> Id (Id A b c) q (comp A b b c (refl A b) q)) rem c q
  where
    rem : Id (Id A b b) (refl A b) (comp A b b b (refl A b) (refl A b))
    rem = compInvIdr A b b (refl A b)


compIdl : (A : U) -> (b c : A) -> (q : Id A b c) ->
             Id (Id A b c) (comp A b b c (refl A b) q) q
compIdl A b c q = inv (Id A b c) q (comp A b b c (refl A b) q) (compInvIdl A b c q)

compInvIdl' : (A : U) (a b : A) (p : Id A a b) ->
               Id (Id A a b) p (compInv A a a b (refl A a) p)
compInvIdl' A a b p = subst'eq A (\x -> Id A x b) a p

compInv : (A : U) -> (a b c : A) -> Id A a b -> Id A a c -> Id A b c
compInv A a b c p r = subst' A (\ x -> Id A x c) a b p r


lemTrans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a b -> Id A a' b'
lemTrans A a a' b b' p q r =
 subst' A (\ x -> Id A x b') a a' p rem
 where
  rem : Id A a b'
  rem = comp A a b b' r q


lem2Trans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a' b' -> Id A a b
lem2Trans A a a' b b' p q r =
 subst' A (\ x -> Id A a x) b' b (inv A b b' q) rem
 where
  rem : Id A a b'
  rem = comp A a a' b' p r

lemInv : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q : Id A b c) ->
         Id (Id A b c) q (compInv A a b c p (comp A a b c p q))
lemInv A a b c p q =
 J A a (\ b p -> (c : A) (q : Id A b c) ->
        Id (Id A b c) q (compInv A a b c p (comp A a b c p q))) rem b p c q
 where
  rem1 : (c : A) (q : Id A a c) ->
          Id (Id A a c) (comp A a a c (refl A a) q)
                        (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
  rem1 c q = compInvIdl' A a c (comp A a a c (refl A a) q)

  rem2 : (c : A) (q : Id A a c) -> Id (Id A a c) q (comp A a a c (refl A a) q)
  rem2 c q = compInvIdl A a c q

  rem : (c : A) (q : Id A a c) ->
          Id (Id A a c) q (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
  rem c q = comp (Id A a c) q
                        (comp A a a c (refl A a) q)
                        (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
                        (rem2 c q)
                        (rem1 c q)


lemSimpl : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q q' : Id A b c) ->
   Id (Id A a c) (comp A a b c p q) (comp A a b c p q') -> Id (Id A b c) q q'
lemSimpl A a b c p q q' h =
 lem2Trans (Id A b c)
           q (compInv A a b c p (comp A a b c p q)) q' (compInv A a b c p (comp A a b c p q'))
           rem rem1 rem2
 where
   rem : Id (Id A b c) q (compInv A a b c p (comp A a b c p q))
   rem = lemInv A a b c p q

   rem1 : Id (Id A b c) q' (compInv A a b c p (comp A a b c p q'))
   rem1 = lemInv A a b c p q'

   rem2 : Id (Id A b c) (compInv A a b c p (comp A a b c p q))
                        (compInv A a b c p (comp A a b c p q'))
   rem2 = cong (Id A a c) (Id A b c) (compInv A a b c p)
               (comp A a b c p q) (comp A a b c p q') h


lem1 : (A :U) -> (a:A) -> (h : (x:A) -> Id A a x) ->
       (x y : A) -> (p : Id A x y) -> Id (Id A a y) (comp A a x y (h x) p) (h y)
lem1 A a h x =
  J A x (\ y p -> Id (Id A a y) (comp A a x y (h x) p) (h y)) rem
 where
   rem : Id (Id A a x) (comp A a x x (h x) (refl A x)) (h x)
   rem = compIdr A a x (h x)

lem2 : (A :U) -> (a:A) -> ((x:A) -> Id A a x) -> UIP A
lem2 A a h x y p q =
 lemSimpl A a x y (h x) p q rem
   where
     remp : Id (Id A a y) (comp A a x y (h x) p) (h y)
     remp = lem1 A a h x y p
     remq : Id (Id A a y) (comp A a x y (h x) q) (h y)
     remq = lem1 A a h x y q
     rem : Id (Id A a y) (comp A a x y (h x) p) (comp A a x y (h x) q)
     rem = lem2Trans (Id A a y) (comp A a x y (h x) p) (h y) (comp A a x y (h x) q) (h y)
               remp remq (refl (Id A a y) (h y))


lem3 : (A:U) -> prop A -> UIP A
lem3 A h a = lem2 A a (h a) a

data Unit = tt

propunit : prop Unit
propunit = split
  tt -> split
     tt -> refl Unit ($ tt)

lemunit : UIP Unit
lemunit = lem3 Unit propunit

test2 : Id (Id Unit ($ tt) ($ tt) ) (refl Unit ($ tt)) (refl Unit ($ tt))
test2 = lemunit($ tt) ($ tt)(refl Unit ($ tt))(refl Unit ($ tt))

inhuip : (A : U) -> UIP (inh A)
inhuip A = lem3 (inh A) (squash A)

data N = zero | suc (n : N)

zz : inh N
zz = inc N ($ zero)

eq1 : Id (inh N) zz zz
eq1 = refl (inh N) zz

eq2 : Id (inh N) zz zz
eq2 = squash N zz zz

test : Id (Id (inh N) zz zz) eq1 eq2
test = inhuip N zz zz eq1 eq2

data N0 =

neg : U -> U
neg A = A -> N0

efq : (A : U) -> N0 -> A
efq A = split {}

data or (A B : U) = inl (a : A) | inr (b : B)

dec : U -> U
dec A = or A (neg A)

data Sigma (A : U) (B : A -> U) = pair (x : A) (y : B x)

fiber : (A B : U) (f : A -> B) (y : B) -> U
fiber A B f y = Sigma A (graph A B f y)

graph : (A B : U) -> (f : A -> B) -> B -> A -> U
graph A B f y x = Id B (f x) y

const : (A : U) (f : A -> A) -> U
const A f = (x y : A) -> Id A (f x) (f y)

exConst : (A : U) -> U
exConst A = Sigma (A -> A) (const A)

decConst : (A : U) -> dec A -> exConst A
decConst A = split
  inl a -> $ pair (\x -> a) (\ x y -> refl A a)
  inr h -> $ pair (\x -> x) (\ x y -> efq (Id A x y) (h x))


mainLemma : (A: U) (f : (a b : A) -> Id A a b -> Id A a b) (a b : A)
            (p : Id A a b) ->
            Id (Id A a b) (comp A a a b (f a a (refl A a)) p) (f a b p)
mainLemma A f a = J A a (\ b p -> Id (Id A a b) (comp A a a b (f a a (refl A a)) p) (f a b p)) rem
  where rem : Id (Id A a a) (comp A a a a (f a a (refl A a)) (refl A a)) (f a a (refl A a))
        rem = compIdr A a a (f a a (refl A a))

discrete : U -> U
discrete A = (a b : A) -> dec (Id A a b)

fst : (A : U) (B : A -> U) -> Sigma A B -> A
fst A B = split
  pair a b -> a

snd : (A : U) (B : A -> U) (p : Sigma A B) -> B (fst A B p)
snd A B = split
  pair a b -> b

hedberg : (A : U) -> discrete A -> UIP A
hedberg A h a b p q = lemSimpl A a a b r p q rem5
  where
    rem1 : (x y : A) -> exConst (Id A x y)
    rem1 x y = decConst (Id A x y) (h x y)

    f : (x y : A) -> Id A x y -> Id A x y
    f x y = fst (Id A x y -> Id A x y) (const (Id A x y)) (rem1 x y)

    fisconst : (x y : A) -> const (Id A x y) (f x y)
    fisconst x y = snd (Id A x y -> Id A x y) (const (Id A x y)) (rem1 x y)

    r : Id A a a
    r = f a a (refl A a)

    rem2 : Id (Id A a b) (comp A a a b r p) (f a b p)
    rem2 = mainLemma A f a b p

    rem3 : Id (Id A a b) (comp A a a b r q) (f a b q)
    rem3 = mainLemma A f a b q

    rem4 : Id (Id A a b) (f a b p) (f a b q)
    rem4 = fisconst a b p q

    rem5 : Id (Id A a b) (comp A a a b r p) (comp A a a b r q)
    rem5 = lem2Trans (Id A a b) (comp A a a b r p) (f a b p) (comp A a a b r q) (f a b q) rem2 rem3 rem4



znots : (n : N) -> neg (Id N ($ zero) ($ suc n))
znots n h = subst' N T ($ zero) ($ suc n) h ($ zero)
  where
    T : N -> U
    T = split
          zero -> N
          suc n -> N0

snotz : (n : N) -> neg (Id N ($ suc n) ($ zero))
snotz n h = znots n (inv N ($ suc n) ($ zero) h)

pred : N -> N
pred = split
  zero -> $ zero
  suc n -> n

sucInj : (n m : N) -> Id N ($ suc n) ($ suc m) -> Id N n m
sucInj n m h = cong N N pred ($ suc n) ($ suc m) h

sucCong : (n m : N) -> Id N n m -> Id N ($ suc n) ($ suc m)
sucCong n m h = cong N N (\n -> $ suc n) n m h

decEqCong : (A B : U) (f : A -> B) (g : B -> A) -> dec A -> dec B
decEqCong A B f g = split
  inl a -> $inl (f a)
  inr h -> $inr (\b -> h (g b))


natDec : discrete N
natDec = split
  zero  -> split
    zero -> rem
      where rem : dec (Id N ($ zero) ($ zero))
            rem = $ inl (refl N ($ zero))
    suc m -> $ inr (znots m)
  suc n -> split
    zero -> $ inr (snotz n)
    suc m -> decEqCong (Id N n m) (Id N ($ suc n) ($ suc m))
                       (sucCong n m) (sucInj n m) (natDec n m)

NIsSet : UIP N
NIsSet = hedberg N natDec

test3 : Id (Id N ($ zero) ($ zero)) (refl N ($ zero)) (refl N ($ zero))
test3 = NIsSet ($ zero) ($ zero) (refl N ($ zero)) (refl N ($ zero))

data Bool = true | false

tnotf : neg (Id Bool ($ true) ($ false))
tnotf h = subst' Bool T ($ true) ($ false) h ($ zero)
  where
    T : Bool -> U
    T = split
          true  -> N
          false -> N0

fnott : neg (Id Bool ($ false) ($ true))
fnott h = tnotf (inv Bool ($ false) ($ true) h)


boolDec : discrete Bool
boolDec = split
  true -> split
    true -> $ inl (refl Bool ($ true))
    false -> $ inr tnotf
  false -> split
    true -> $ inr fnott
    false -> $ inl (refl Bool ($ false))


boolIsSet : UIP Bool
boolIsSet = hedberg Bool boolDec


-- subst' : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
eqSigma : (A : U) (B : A -> U) (a b : A) (p : Id A a b)
          (u : B a) (v : B b) (q : Id (B b) (subst' A B a b p u) v) ->
          Id (Sigma A B) ($ pair a u) ($ pair b v)
eqSigma A B a =
  J A a (\b p -> (u : B a) (v : B b) (q : Id (B b) (subst' A B a b p u) v) ->
         Id (Sigma A B) ($ pair a u) ($ pair b v)) rem2
  where
    rem1 : (u v : B a) -> Id (B a) u v ->
           Id (Sigma A B) ($ pair a u) ($ pair a v)
    rem1 = cong (B a) (Sigma A B) (\x -> $ pair a x)

    rem2 : (u v : B a) -> Id (B a) (subst' A B a a (refl A a) u) v ->
           Id (Sigma A B) ($ pair a u) ($ pair a v)
    rem2 u v q = rem1 u v q'
      where q' : Id (B a) u v
            q' = comp (B a) u (subst' A B a a (refl A a) u) v (subst'eq A B a u) q

propFam : (A : U) (B : A -> U) -> U
propFam A B = (a : A) -> prop (B a)

eqPropFam : (A : U) (B : A -> U) (h : propFam A B) (au bv : Sigma A B) ->
            Id A (fst A B au) (fst A B bv) -> Id (Sigma A B) au bv
eqPropFam A B h = split
  pair a u -> split
    pair b v -> \p -> eqSigma A B a b p u v (h b (subst' A B a b p u) v)

exist : (A : U) (B : A -> U) -> U
exist A B = inh (Sigma A B)

-- TODO: fix parser for "Fun"
exElim : (A : U) (B : A -> U) (C : U) (_ : prop C) (_ : Sigma A B -> C)
         (_ : exist A B) -> C
exElim A B C p f = inhrec (Sigma A B) C p f

atmostOne : (A : U) (B : A -> U) -> U
atmostOne A B = (a b : A) -> B a -> B b -> Id A a b

propSig : (A : U) (B : A -> U) -> propFam A B -> atmostOne A B ->
          prop (Sigma A B)
propSig A B h h' au bv =
  eqPropFam A B h au bv (h' (fst A B au) (fst A B bv) (snd A B au) (snd A B bv))

and : (A B : U) -> U
and A B = Sigma A (\_ -> B)

exactOne : (A : U) (B : A -> U) -> U
exactOne A B = and (exist A B) (atmostOne A B)

lemInh : (A : U) -> prop A -> inh A -> A
lemInh A h = inhrec A A h (\x -> x)

descrAx : (A : U) (B : A -> U) -> propFam A B -> exactOne A B -> Sigma A B
descrAx A B h = split
  pair g h' -> lemInh (Sigma A B) rem g
  where rem : prop (Sigma A B)
        rem = propSig A B h h'

iota : (A : U) (B : A -> U) (h : propFam A B) (h' : exactOne A B) -> A
iota A B h h' = fst A B (descrAx A B h h')

iotaSound : (A : U) (B : A -> U) (h : propFam A B) (h' : exactOne A B) -> B (iota A B h h')
iotaSound A B h h' = snd A B (descrAx A B h h')

exAtOne : (A : U) (B : A -> U) -> exactOne A B -> atmostOne A B
exAtOne A B = split
  pair g h' -> h'


iotaLem : (A : U) (B : A -> U) (h : propFam A B) (h' : exactOne A B) ->
          (a : A) -> B a -> Id A a (iota A B h h')
iotaLem A B h h' a p = exAtOne A B h' a (iota A B h h') p (iotaSound A B h h')

rel : U -> U
rel A = A -> A -> U

reflexive : (A : U) -> rel A -> U
reflexive A R = (a : A) -> R a a

euclidean : (A : U) -> rel A -> U
euclidean A R = (a b c : A) -> R a c -> R b c -> R a b

symmetry : (A : U) -> rel A -> U
symmetry A R = (a b : A) -> R a b -> R b a

equivalence : (A : U) -> rel A -> U
equivalence A R = and (reflexive A R) (euclidean A R)

eqToRefl : (A : U) (R : rel A) -> equivalence A R -> reflexive A R
eqToRefl A R = split
  pair r _ -> r

eqToEucl : (A : U) (R : rel A) -> equivalence A R -> euclidean A R
eqToEucl A R = split
  pair _ e -> e

eqToSym : (A : U) (R : rel A) -> equivalence A R -> symmetry A R
eqToSym A R = split
  pair r e -> \a b -> e b a b (r b)

eqToInvEucl : (A : U) (R : rel A) -> equivalence A R ->
              (a b c : A) -> R c a -> R c b -> R a b
eqToInvEucl A R eq a b c p q =
  eqToEucl A R eq a b c (eqToSym A R eq c a p) (eqToSym A R eq c b q)

test13 : (A : U) (R : rel A) (P : A -> U) -> U
test13 A R P = propFam A P


data Quot (A : U) (R : rel A) =
  class (P : A -> U)
        (un : (a b : A) -> P a -> P b -> R a b)
        (cp : (a b : A) -> P a -> R a b -> P b)
        (ex : exist A P)
        (pr : propFam A P)

propRel : (A : U) (R : rel A) -> U
propRel A R = (a b : A) -> prop (R a b)

canSurj : (A : U) (R : rel A) -> equivalence A R -> propRel A R ->
            A -> Quot A R
canSurj A R h h' c = $ class (R c) un cp ex pr
  where un : (a b : A) -> R c a -> R c b -> R a b
        un a b p q = eqToInvEucl A R h a b c p q

        cp : (a b : A) -> R c a -> R a b -> R c b
        cp a b p q = eqToEucl A R h c b a p (eqToSym A R h a b q)
        ex : exist A (R c)
        ex = inc (Sigma A (R c)) ($ pair c (eqToRefl A R h c))
        pr : propFam A (R c)
        pr a = h' c a

resp : (A B : U) (R : rel A) (f : A -> B) -> U
resp A B R f = (x y : A) -> R x y -> Id B (f x) (f y)

image : (A B : U) (f : A -> B) (P : A -> U) -> B -> U
image A B f P b = exist A (\a -> and (P a) (Id B (f a) b))

propAnd : (A B : U) -> prop A -> prop B -> prop (and A B)
propAnd A B p q = propSig A F rem (\a a' _ _ -> p a a')
  where F : A -> U
        F a = B
        rem : propFam A F
        rem a = q

univQuot : (A B : U) (R : rel A) (f : A -> B) ->
           UIP B -> resp A B R f -> (eqR : equivalence A R) (pR : propRel A R)
--         Sigma
                 (_ : Quot A R) -> B
--               (\g -> (a : A) -> Id B (f a) (g (canSurj A R eqR pR a)))
univQuot A B R f uip fresp eqR pR = g -- $ pair g rem
  where
    g : Quot A R -> B
    g = split
      class P un cp ex pr -> iota B imfP rem1 rem2
        where
          imfP : B -> U
          imfP = image A B f P
          rem1 : propFam B imfP
          rem1 b = squash (Sigma A (\a -> and (P a) (Id B (f a) b)))
          rem2 : exactOne B imfP
          rem2 = $ pair rem4 rem5

          rem3 : Sigma A P -> exist B imfP
          rem3 = split
            pair a p -> inc (Sigma B imfP)
                        ($ pair (f a) (inc (Sigma A (S (f a))) ($ pair a ($ pair p (refl B (f a))))))
          rem4 : exist B imfP
          rem4 = inhrec (Sigma A P) (exist B imfP) (squash (Sigma B imfP)) rem3 ex

          rem5 : atmostOne B imfP
          rem5 = rem9

          rem6 : (b b' : B) (a a' : A) (_ : and (P a) (Id B (f a) b))
             (_ : and (P a') (Id B (f a') b')) -> Id B b b'
          rem6 b b' a a' = split
            pair p ea -> split
              pair p' ea' -> lemTrans B (f a) b (f a') b' ea ea' rem7
                where rem7 : Id B (f a) (f a')
                      rem7 = fresp a a' rem8
                      rem8 : R a a'
                      rem8 = un a a' p p'

          S : B -> A -> U
          S b a = and (P a) (Id B (f a) b)
          rem7 : (b b' : B)  (_ : Sigma A (S b)) (_ : Sigma A (S b'))
             -> Id B b b'
          rem7 b b' = split
            pair a p -> split
              pair a' p' -> rem6 b b' a a' p p'

          rem8 : (b b' : B) -> Sigma A (S b) -> exist A (S b') -> Id B b b'
          rem8 b b' h = exElim A (S b') (Id B b b') (uip b b') (rem7 b b' h)

          rem9 : (b b' : B) -> exist A (S b) -> exist A (S b') -> Id B b b'
          rem9 b b' h h' = exElim A (S b) (Id B b b') (uip b b')
                        (\h'' -> rem8 b b' h'' h') h


kernel : (A B : U) (f : A -> B) -> rel A
kernel A B f a a' = Id B (f a) (f a')

kerRef : (A B : U) (f : A -> B) -> reflexive A (kernel A B f)
kerRef A B f a = refl B (f a)

kerEucl : (A B : U) (f : A -> B) -> euclidean A (kernel A B f)
kerEucl A B f a b c p q = compInv B (f c) (f a) (f b) rem rem1
 where rem : Id B (f c) (f a)
       rem = inv B (f a) (f c) p
       rem1 : Id B (f c) (f b)
       rem1 = inv B (f b) (f c) q

kerEquiv : (A B : U) (f : A -> B) -> equivalence A (kernel A B f)
kerEquiv A B f = $ pair (kerRef A B f) (kerEucl A B f)

not : Bool -> Bool
not = split
  true -> $ false
  false -> $ true


isEven : N -> Bool
isEven = split
  zero -> $ true
  suc n -> not (isEven n)

mod2 : rel N
mod2 = kernel N Bool isEven

propMod2 : propRel N mod2
propMod2 n m = boolIsSet (isEven n) (isEven m)

Z2 : U
Z2 = Quot N mod2

respIsEven : resp N Bool mod2 isEven
respIsEven n m h = h

barIsEven : Z2 -> Bool
barIsEven = univQuot N Bool mod2 isEven boolIsSet respIsEven (kerEquiv N Bool isEven) propMod2


five : N
five = $ suc ($ suc ($ suc ($ suc  ($ suc ($ zero)))))

fiveBar : Z2
fiveBar = canSurj N mod2 (kerEquiv N Bool isEven) propMod2 five

test5 : Bool
test5 = barIsEven fiveBar


notK : (x : Bool) -> Id Bool (not (not x)) x
notK = split
  true  -> refl Bool ($ true)
  false -> refl Bool ($ false)

notInj : (x y : Bool) -> Id Bool (not x) (not y) -> Id Bool x y
notInj x y p = lemTrans Bool (not (not x)) x (not (not y)) y (notK x) (notK y) rem
  where
  rem : Id Bool (not (not x)) (not (not y))
  rem = cong Bool Bool not (not x) (not y) p

notFiber : Bool -> U
notFiber b = fiber Bool Bool not b

fstNotFiber : (b : Bool) -> notFiber b -> Bool
fstNotFiber b = fst Bool (\x -> Id Bool (not x) b)

eqNotFiber : (b : Bool) -> (v v' : notFiber b) ->
  Id Bool (fstNotFiber b v) (fstNotFiber b v') -> Id (notFiber b) v v'
eqNotFiber b = eqPropFam Bool (\x -> Id Bool (not x) b) rem
  where
  rem : propFam Bool (\x -> Id Bool (not x) b)
  rem = \x -> boolIsSet (not x) b

sNot : (b : Bool) -> notFiber b
sNot b = $ pair (not b) (notK b)

tNot : (b : Bool) (v : notFiber b) -> Id (notFiber b) (sNot b) v
tNot b v = eqNotFiber b (sNot b) v rem
  where
  b' : Bool
  b' = fstNotFiber b v

  rem : Id Bool (not b) b'
  rem = notInj (not b) b' rem1

  rem1 : Id Bool (not (not b)) (not b')
  rem1 = comp Bool (not (not b)) b (not b') (notK b)
         (inv Bool (not b') b (snd Bool (\x -> Id Bool (not x) b) v))

eqBoolBool : Id U Bool Bool
eqBoolBool = equivEq Bool Bool not sNot tNot

transport : (A B : U) -> Id U A B -> A -> B
transport = subst U (\x -> x)

transportInv : (A B : U) -> Id U A B -> B -> A
transportInv = substInv U (\x -> x)

notEqBool : Bool -> Bool
notEqBool = transportInv Bool Bool eqBoolBool

testBool : Bool
testBool = notEqBool ($ true)

transport' : (A B : U) -> Id U A B -> A -> B
transport' = subst' U (\x -> x)

monoid : U -> U
monoid A = and A (A -> A -> A) 

zm : (A : U) (m : monoid A) -> A
zm A m = fst A (\x -> A -> A -> A) m

opm : (A : U) (m : monoid A) -> (A -> A -> A)
opm A m = snd A (\x -> A -> A -> A) m

transm : (A B : U) -> Id U A B -> monoid A -> monoid B
transm = subst U monoid 

transun : (A B : U) -> Id U A B -> (A -> A) -> (B -> B)
transun = subst U (\X -> (X -> X))

transid : Bool -> Bool
transid = transun Bool Bool eqBoolBool (\x -> x) 

testT : Bool
testT = transid True

testT' : Bool
testT' = transun Bool Bool (refl U Bool) (\x -> x) True

testF : Bool
testF = transid False

andBool : Bool -> Bool -> Bool
andBool = split
  true -> \x -> x
  false -> \x -> $ false

mBool1 : monoid Bool
mBool1 = $ pair ($ true) andBool

mBool2 : monoid Bool
mBool2 = transm Bool Bool eqBoolBool mBool1

opBool2 : Bool -> Bool -> Bool
opBool2 = opm Bool mBool2

True : Bool
True = $ true

False : Bool
False = $ false

testTF : Bool
testTF = opBool2 True False

testFT : Bool
testFT = opBool2 False True

testFF : Bool
testFF = opBool2 False False

testTT : Bool
testTT = opBool2 True True



--  subst : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x





-- negUIP : neg (UIP U)
-- negUIP uipU =
--   where
--   eqreflnot : Id (Id U Bool Bool) (refl U Bool) eqBoolBool
--   eqreflnot = uipU Bool Bool (refl U Bool) eqBoolBool

--   frefl : Bool -> Bool
--   frefl = transport' Bool Bool (refl U Bool)

--   fnot : Bool -> Bool
--   fnot = transport' Bool Bool eqBoolBool

--   lem1 : Id (Bool -> Bool) frefl fnot
--   lem1 = cong (Id U Bool Bool) (Bool -> Bool) (transport' Bool Bool) (refl U Bool) eqBoolBool eqreflnot

--   lem2 : Id Bool ($ true) (frefl ($ true))
--   lem2 = subst'eq U (\x -> x) Bool ($ true)

--   lem3 : Id Bool ($ false) (fnot ($ true))
--   lem3 = -- Cannot be proved yet...

