module Tr2 where

Eq : (A : U) -> (x y : A)-> U
Eq A x y = (P : A -> U) -> P x -> P y

refl : (A : U) -> (x : A) -> Eq A x x
refl A x P p = p

mutual
  V : forall i. U
  data V <i> = `U
             | `Pi (A : V@i) (B : El@i A -> V@i)
             | `K

                  (A : forall j. U)
                  (f : A@0 -> A@1)
                  (g : (x:A@0) -> (A ? x & (f x)))

                  -- (A : U)
                  -- (f : A/0/i -> A/1/i)
                  -- (g : (x:A/0/i) -> (let X : forall j. U
                  --                        X = <j> A/j/i
                  --                    in X ? x & (f x)))


  El :  forall i. V@i -> U
  El = <i> split
                      `U -> U
                      `Pi A B -> (x : El@i A) -> El@i (B x)
                      `K A _ _ -> A@0@i

                       -- @0 because the color dependency was made
                       -- explicit in the data definition; we want to
                       -- ignore the implicit color i in there.


--     T:forall i. V  |-  T : forall i. V
-- --------------------------------------------
--     T:V@i |-  T/0/i : V@0


--     Γ,∀i.Δ  |-  t : A[Δ@i]
-- --------------------------------------------
--     Γ,i,Δ   |-  t/0/i : A@0


--     Γ,∀i.Δ  |-  t : A[Δ@i]
-- --------------------------------------------
--     Γ,i,Δ   |-  t@i : A@i

lifting : forall i. (T : V@i) -> El@0 T/0/i -> El@i T
lifting = <i> split
   `U -> \A -> A
   `Pi A B -> \f a -> lifting@i (B a) (f a/0/i)
   `K A f g -> \x -> [x@0 & f@0 x@0 , g@0 x@0]@i


lift : (T : forall i. V@i) (z : El@0 T@0) -> forall i. El@i T@i
lift T z = <i> lifting@i T@i z



List : U -> U
data List A = Nil | Cons (x : A) (xs : List A)

append : (A : U) -> List A -> List A -> List A
append A xs = split
  Nil -> xs
  Cons y ys -> Cons y (append A xs ys)

cong : (A : U) (B : U) -> (f : A -> B) -> (x y : A) -> Eq A x y -> Eq B (f x) (f y)
cong A B f p = _

Lemma : U
Lemma = (A : U) -> (x : List A) -> Eq (List A) (append A x Nil) x

lemma : Lemma
lemma A = split
  Nil -> refl (List A) Nil
  Cons x xs -> cong (List A) (List A) (Cons x) xs (append A xs Nil) (lemma A xs)

Tree : U -> U
data Tree A = Leaf  (x:A) | Bin (l:Tree A) (r : Tree A) | Tip

flatten : (A : U) -> Tree A -> List A
flatten A = split
  Tip -> Nil
  Bin l r -> append A (flatten A r) (flatten A l)
  Leaf x -> Cons x Nil


embed : (A : U) -> List A -> Tree A
embed A = split
  Nil -> Tip
  Cons x xs -> Bin (Leaf x) (embed A xs)

True : U
data True = tt

False : U
data False =

-- EqList : (A : U) -> List A -> List A -> U
-- EqList A = split
--   Nil -> split
--     Nil -> True
--     Cons _ _ -> False
--   Cons x xs -> split
--     Nil -> False
--     Cons y ys -> -- TODO x == y
--                  EqList A xs ys


Related :  (A : U) -> List A -> Tree A -> U
Related A xs t = Eq (List A) xs (flatten A t)

LIST : (A : U) -> forall i. U
LIST A = [List A & Tree A, Psi (Related A) ]

Embed : (A : U) -> (x : List A) -> Related A x (embed A x)
Embed A = split
  Nil -> refl (List A) Nil
  Cons y ys -> cong (List A) (List A) (Cons y) ys (flatten A (embed A ys)) (Embed A ys)

`pList : (A : U) ->  forall i. V@i
`pList A = <i> `K (LIST A) (embed A) (Embed A)

`List : forall i. V@i
`List = <i> `Pi `U (\A -> `K (LIST A) (embed A) (Embed A))

EQ : forall i. (A : U) (x y : A) -> U
EQ = <i> \A x y -> [Eq A@0 x@0 y@0 & Eq A@1 x@1 y@1, Psi (\_ _ -> True)  ]@i

-- f : EQ@0 A x y -> EQ@1 A x y
-- f : Eq A@0 x@0 y@0 -> Eq A@1 x@1 y@1

-- EQList : (A : U) -> forall i. (x y : (LIST A)@i) -> U
-- EQList = \A -> <i> \x y -> [Eq (List A) x@0 y@0 & Eq (List A) (flatten A x@1) (flatten A y@1), Psi (\_ _ -> True)  ]@i

EQList' : (A : U) -> (x y : forall i. (LIST A)@i) -> forall i. U
EQList' = \A x y -> [Eq (List A) x@0 y@0 & Eq (List A) (flatten A x@1) (flatten A y@1), Psi (\_ _ -> True)  ]

`EqList : (A : U) -> forall i.  (x y : (LIST A)@i) -> V@i
`EqList = \A -> <i> \x y -> `K (<j> (EQList' A x y)@i) _ _
   -- Missing:

   -- x@0 = y@0
   -- x@0 = flatten x@1
   -- y@0 = flatten y@1
   -- -------------------------
   -- flatten x@1 = flatten y@1

NIL :  (A : U) -> forall i. (LIST A)@i
NIL A = <i> [Nil & Tip, refl (List A) Nil ]@i

APPEND :  (A : U) -> forall i. (LIST A)@i -> (LIST A)@i -> (LIST A)@i
APPEND A = <i> \xs ys -> [ append A xs@0 ys@0 & Bin xs@1 ys@1 , _]@i

-- Missing:
-- xs@0 = flatten xs@1
-- ys@0 = flatten ys@1
------------------------------------------------
-- append A xs@0 ys@0 = flatten (Bin xs@1 ys@1)

`Lemma : (A : U) -> forall i. V@i
`Lemma A = <i> `Pi (`pList A)@i (\x ->
               (`EqList A)@i ((APPEND A)@i x (NIL A)@i) x)

-- El@0 (`Lemma A)@0 = Lemma A
-- El@1 (`Lemma A)@1 = (xs : Tree A) -> flatten (Bin xs Tip) = flatten xs

-- This is tedious. Can we lift types?

